runApp("c:/users/kristan/dropbox/map/timespace", launch.browser=TRUE)
runApp("c:/users/kristan/dropbox/map/timespace", launch.browser=TRUE)
runApp("c:/users/kristan/dropbox/map/timespace", launch.browser=TRUE)
runApp("c:/users/kristan/dropbox/map/timespace", launch.browser=TRUE)
runApp("c:/users/kristan/dropbox/map/timespace", launch.browser=TRUE)
runApp("c:/users/kristan/dropbox/map/timespace", launch.browser=TRUE)
runApp("c:/users/kristan/dropbox/map/timespace", launch.browser=TRUE)
runApp("c:/users/kristan/dropbox/map/timespace", launch.browser=TRUE)
runApp("c:/users/kristan/dropbox/map/timespace", launch.browser=TRUE)
runApp("c:/users/kristan/dropbox/map/timespace", launch.browser=TRUE)
runApp("c:/users/kristan/dropbox/map/timespace", launch.browser=TRUE)
runApp("c:/users/kristan/dropbox/map/timespace", launch.browser=TRUE)
runApp("c:/users/kristan/dropbox/map/timespace", launch.browser=TRUE)
runApp("c:/users/kristan/dropbox/map/timespace", launch.browser=TRUE)
runApp("c:/users/kristan/dropbox/map/timespace", launch.browser=TRUE)
runApp("c:/users/kristan/dropbox/map/timespace", launch.browser=TRUE)
runApp("c:/users/kristan/dropbox/map/timespace", launch.browser=TRUE)
runApp("c:/users/kristan/dropbox/map/timespace", launch.browser=TRUE)
runApp("c:/users/kristan/dropbox/map/timespace", launch.browser=TRUE)
runApp("c:/users/kristan/dropbox/map/timespace", launch.browser=TRUE)
runApp("c:/users/kristan/dropbox/map/timespace", launch.browser=TRUE)
runApp("c:/users/kristan/dropbox/map/timespace", launch.browser=TRUE)
runApp("c:/users/kristan/dropbox/map/timespace", launch.browser=TRUE)
runApp("c:/users/kristan/dropbox/map/timespace", launch.browser=TRUE)
install.packages("SGP")
install.packages("devtools") # if not installed
library(devtools)
install_github("tesseradata/datadr")
install_github("tesseradata/trelliscope")
library(datadr); library(trelliscope)
library(SGP)
help("SGP")
install.packages("SGPdata")
library("SGPdata")
help("SGPdata")
?SGPdata
help("SGP")
my.grade.sequences <- list(3:4, 3:5, 3:6, 3:7, 4:8)
my.sgpData <- list(Panel_Data = sgpData)
str(my.sgpData)
my.sgpData <- list(Panel_Data = sgpData)
for (i in seq_along(my.grade.sequences)) {
my.sgpData <- studentGrowthPercentiles(panel.data=my.sgpData,
sgp.labels=list(my.year=2013, my.subject="Reading"),
use.my.knots.boundaries="DEMO",
grade.progression=my.grade.sequences[[i]])
}
my.grade.progressions <- list(3, 3:4, 3:5, 3:6, 4:7)
for (i in seq_along(my.grade.progressions)) {
my.sgpData <- studentGrowthProjections(panel.data=my.sgpData,
sgp.labels=list(my.year=2013, my.subject="Reading"),
projcuts.digits=0,
projection.unit="GRADE",
performance.level.cutscores="DEMO",
percentile.trajectory.values=c(25, 50, 75),
grade.progression=my.grade.progressions[[i]])
}
write.csv(my.sgpData$SGProjections$READING.2013,
file= "2013_Reading_SGProjections.csv", row.names=FALSE, quote=FALSE)
getwd()
head(my.sgpData$SGProjections$READING.2013)
data <- SGPDataLong
data <- data(sgpData_Long)
data <- data(sgpData_LONG)
head(data)
data(sgpData_LONG)
head(sgpData_LONG)
head(my.sgpData)
head(sgpData)
head(sgpData_LONG)
reading <- sgpData_LONG[sgpData_LONG$CONTENT_AREA=="READING"]
reading <- sgpData_LONG[sgpData_LONG$CONTENT_AREA=="READING",]
head(reading)
library(lmer)
library(lme4)
?lmer
reading[reading$ID==1005798,]
reading[reading$ID=='1005798',]
sgpData_LONG[sgpData_LONG$ID==1005798,]
sgpData_LONG[sgpData_LONG$ID==1006677
,]
table(sgpData_LONG$ID)
head(table(sgpData_LONG$ID))
head(table(sgpData$ID))
?prepareSGP
?analyzeSGP
?lmer
names(sgpData_LONG)
head(sgpData)
sgpReadingLong <- melt(sgpData, id="ID")
library(reshape2)
sgpReadingLong <- melt(sgpData, id="ID")
head(sgpReadingLong)
?reshape
sgpReadingLong <-reshape(sgpData, varying=c("GRADE", "SS"), ids="ID")
source('~/.active-rstudio-document', echo=TRUE)
sgpReadingLong <-reshape(sgpData, varying=c("GRADE", "SS"), ids="ID", direction="long")
sgpReadingLong <-reshape(sgpData, varying=c("GRADE", "SS"), timevar="Year", ids="ID", direction="long")
sgpReadingLong <-reshape(sgpData, varying=c("GRADE", "SS"), v.names="Year", ids="ID", direction="long")
summary(Indometh)
wide <- reshape(Indometh, v.names = "conc", idvar = "Subject",
timevar = "time", direction = "wide")
wide
names(sgpReadingLong)
names(sgpData_LONG)
names(sgpData)
sgpReadingLong <-reshape(sgpData, varying=c(2:11), v.names=c("GRADE", "SS"), ids="ID", direction="long")
sgpReadingLong <-reshape(sgpData, varying=c(2:11), v.names=c("GRADE", "SS"), idvar="ID", direction="long")
head(sgpReadingLong)
sgpReadingLong <-reshape(sgpData, varying=c(2:11), v.names=c("GRADE", "SS"), idvar="ID", sep="_", direction="long")
head(sgpReadingLong)
summary(Indometh)
wide <- reshape(Indometh, v.names = "conc", idvar = "Subject",
timevar = "time", direction = "wide")
wide
reshape(wide, direction = "long")
reshape(wide, idvar = "Subject", varying = list(2:12),
v.names = "conc", direction = "long")
sgpReadingLong <-reshape(sgpData, direction="long")
sgpReadingLong <-reshape(sgpData, varying=c(2:11), idvars="ID", direction="long")
sgpReadingLong <-reshape(sgpData, varying=c(2:11), direction="long")
sgpReadingLong <-reshape(sgpData, varying=c(2:11), sep="_", direction="long")
head(sgpReadingLong)
install.packages("xlsx")
data <- read.xlsx("c:/users/kristan/downloads/Call List Sample - 2014 Third House Friendlies (1).xlsx")
library(xlsx)
data <- read.xlsx("c:/users/kristan/downloads/Call List Sample - 2014 Third House Friendlies (1).xlsx")
data <- read.xlsx("c:/users/kristan/downloads/Call List Sample - 2014 Third House Friendlies (1).xlsx", sheetIndex=1)
head(data)
data[1,]
data[2,]
data[3,]
?odds
?odd
data <- read.xlsx("c:/users/kristan/downloads/Call List Sample - 2014 Third House Friendlies (1).xlsx", sheetIndex=1)
head(data)
data <- read.xlsx("c:/users/kristan/dropbox/convertics/donor conversion/data/HROCCallList.xlsx", sheetIndex=1)
data <- read.xlsx("c:/users/kristan/dropbox/convertics/donor conversion/data/HROCCallList.xlsx", sheetIndex=1, header=FALSE)
rownames(data)%%2
rownames(data)
is.numeric(rownames(data))
as.numeric(rownames(data))%%2
dataEvenRows <- data[as.numeric(rownames(data))%%2==0,]
head(dataEvenRows)
dataOddRows <- data[as.numeric(rownames(data))%%2==1,]
dim(dataEvenRows)
dim(dataOddRows)
data <- read.xlsx("c:/users/kristan/dropbox/convertics/donor conversion/data/HROCCallList.xlsx", sheetIndex=1, header=FALSE)
dataEvenRows <- data[as.numeric(rownames(data))%%2==0,]
dataOddRows <- data[as.numeric(rownames(data))%%2==1,]
coltoremove <- NA
for(i in 1:ncol(dataEvenRows)){
tmp <- length(dataEvenRows[,i][is.na(dataEvenRows[,i])])
if(tmp==dim(dataEvenRows)[2]){
coltoremove <- c(coltoremove, i)
}
}
tmp <- length(dataEvenRows[,i][is.na(dataEvenRows[,i])])
tmp
dim(dataEvenRows)[2]
dim(dataEvenRows)
head(dataEvenRows)
dataEvenRows[1,2]
dim(dataEvenRows)[2]
}
coltoremove <- NA
for(i in 1:ncol(dataEvenRows)){
tmp <- length(dataEvenRows[,i][is.na(dataEvenRows[,i])])
if(tmp==dim(dataEvenRows)[1]){
coltoremove <- c(coltoremove, i)
}
}
head(dataEvenRows)
coltoremove <- coltoremove[-1]
dataEvenRows2 <- dataEvenRows[,-coltoremove]
coltoremove <- NA
for(i in 1:ncol(dataOddRows)){
tmp <- length(dataOddRows[,i][is.na(dataOddRows[,i])])
if(tmp==dim(dataOddRows)[1]){
coltoremove <- c(coltoremove, i)
}
}
coltoremove <- coltoremove[-1]
dataOddRows2 <- dataOddRows[,-coltoremove]
head(dataOddRows2)
alldata <- data.frame(dataOddRows2, dataEvenRows2)
library(reshape2)
alldata$X7
alldata$X8
alldata <- alldata[,-c(7,8)]
head(alldata)
alldata$X28
alldata$X29
alldata$X30
alldata$X31
head(alldata)
datamelt <- melt(alldata, id.vars=c("X1", "X2", "X3", "X4", "X5", "X6", "X2.1"))
head(datamelt)
datamelt$X2.1
head(datamelt)
datamelt <- datamelt[,-8]
names(datamelt) <- c("Name", "Address", "Phone", "Fax", "Cell", "Email", "CityStateZip", "Contributor")
allcontrib <- read.csv("c:/users/kristan/dropbox/convertics/donor conversion/data/allcontributors.csv", stringsAsFactors=FALSE)
head(allcontrib)
library(stringdist)
test <- amatch(allcontrib$NamesNormalized, datamelt$Contributor, maxDist=3)
head(test)
?amatch
test <- amatch(datamelt$Contributor, allcontrib$NamesNormalized, maxDist=3)
head(test)
test <- amatch(datamelt$Contributor, allcontrib$NamesNormalized, method="lv")
head(test)
length(test[is.na(test)])
length(test)
test <- amatch(datamelt$Contributor, allcontrib$NamesNormalized, method="dl")
datamelt$Contributor <- toupper(datamelt$Contributor)
test <- amatch(datamelt$Contributor, allcontrib$NamesNormalized, method="lv")
length(test[is.na(test)])
test <- amatch(datamelt$Contributor, allcontrib$NamesNormalized, maxDist=5)
length(test[is.na(test)])
head(datamelt)
write.csv(datamelt, file="HROCCleaned.csv")
getwd()
write.csv(datamelt, file="HROCCleaned.csv")
install.packages("~/GitHub/alacer-trelliscope.zip", repos = NULL)
library(trelliscope)
devtools::install_github("hafen/housingData")
library(housingData)
head(housing)
byCounty <- divide(housing,
by = c("county", "state"), update = TRUE)
# look at summaries
summary(byCounty)
priceQ <- drQuantile(byCounty,
var = "medListPriceSqft")
xyplot(q ~ fval, data = priceQ,
scales = list(y = list(log = 10)))
priceQ <- drQuantile(byCounty,
var = "medListPriceSqft")
xyplot(q ~ fval, data = priceQ,
scales = list(y = list(log = 10)))
# slope of fitted line of list price for each county
lmCoef <- function(x)
coef(lm(medListPriceSqft ~ time, data = x))[2]
# apply lmCoef to each subset
byCountySlope <- addTransform(byCounty, lmCoef)
# look at a subset of transformed data
byCountySlope[[1]]
# recombine all slopes into a single data frame
countySlopes <- recombine(byCountySlope, combRbind)
plot(sort(countySlopes$val))
# make a time series trelliscope display
vdbConn("housingjunk/vdb", autoYes = TRUE)
# make and test panel function
timePanel <- function(x)
xyplot(medListPriceSqft + medSoldPriceSqft ~ time,
data = x, auto.key = TRUE, ylab = "$ / Sq. Ft.")
timePanel(byCounty[[1]][[2]])
# make and test cognostics function
priceCog <- function(x) { list(
slope = cog(lmCoef(x), desc = "list price slope"),
meanList = cogMean(x$medListPriceSqft),
listRange = cogRange(x$medListPriceSqft),
nObs = cog(sum(!is.na(x$medListPriceSqft)),
desc = "number of non-NA list prices")
)}
priceCog(byCounty[[1]][[2]])
# add display panel and cog function to vdb
makeDisplay(byCounty,
name = "list_sold_vs_time",
desc = "List and sold price over time",
panelFn = timePanel, cogFn = priceCog,
width = 400, height = 400,
lims = list(x = "same"))
# view the display
view()
remove.packages("trelliscope", lib="~/R/win-library/3.1")
install.packages("~/GitHub/alacer-trelliscope.zip", repos = NULL)
library(trelliscope)
view()
install.packages("~/GitHub/trelliscope.zip", repos = NULL)
remove.packages("trelliscope", lib="~/R/win-library/3.1")
install.packages("~/GitHub/trelliscope.zip", repos = NULL)
###set working directory and read in mitdb data record 100
setwd("c:/users/kristan/documents/github/trelliscope/data/mitdb")
r100 <- read.csv("100/100.csv", stringsAsFactors=FALSE, quote="'", header=FALSE, skip=2)
names(r100) <- c("ElapsedTime", "MLII", "V5")
head(r100)
a100 <- read.fwf("100/100ann.txt", stringsAsFactors=FALSE, header=FALSE, widths=c(12,9,7,5,5,4), col.names=c("ElapsedTime", "Sample", "Type", "Sub", "Chan", "Num"), strip.white=TRUE)
a100 <- a100[-1,]
head(a100)
r100$ETime <- strptime(r100$ElapsedTime, format="%M:%OS")
op <- options(digits.secs=3)
head(r100)
r100$Minutes <- as.numeric(format(r100$ETime, "%M"))
r100$Seconds <- as.numeric(format(r100$ETime, "%OS"))+(r100$Minutes*60)
r100$TenSecond <- floor(r100$Seconds/10)
r100$AnnotationTime <- NA
tmp <- as.numeric(a100$Sample)
r100$AnnotationTime[tmp] <- a100$ElapsedTime
r100$AnnotationType <- NA
r100$AnnotationType[tmp] <- a100$Type
r100$AnnotationSub <- NA
r100$AnnotationSub[tmp] <- a100$Sub
r100$AnnotationChan <- NA
r100$AnnotationChan[tmp] <- a100$Chan
r100$AnnotationNum <- NA
r100$AnnotationNum[tmp] <- a100$Num
###############
library(datadr); library(trelliscope)
r100$TenSecond <- as.factor(r100$TenSecond)
r100 <- r100[,-4]
byMin <- divide(r100, by = c("TenSecond"), update = TRUE)
vdbConn("MITDBGraphs/vdb", autoYes = TRUE)
heartCog <- function(x) { list(
meanMLII = cogMean(x$MLII),
RangeMLII = cogRange(x$MLII),
nObs = cog(sum(!is.na(x$MLII)),
desc = "number of sensor readings"),
meanV5 = cogMean(x$V5),
RangeV5 = cogRange(x$V5)
)}
heartCog(byMin[[1]][[2]])
# make and test panel function
timePanel <- function(x)
xyplot(MLII + V5 ~ Seconds,
data = x, auto.key = TRUE, type="l")
timePanel(byMin[[1]][[2]])
timePanelhc <- function(x){
hp <- hPlot(MLII ~ Seconds, data = x, type='line', radius=0)
hp$series(list(data=list(x$V5 ~ x$Seconds)))
hp$colors(c("darkblue"))
hp
}
timePanelhc(byMin[[1]][[2]])
library(rCharts)
timePanelhc <- function(x){
hp <- hPlot(MLII ~ Seconds, data = x, type='line', radius=0)
hp$series(list(data=list(x$V5 ~ x$Seconds)))
hp$colors(c("darkblue"))
hp
}
timePanelhc(byMin[[1]][[2]])
hp <- hPlot(MLII ~ Seconds, data = x, type='line', radius=0)
x <- byMin[[1]][[2]]
hp <- hPlot(MLII ~ Seconds, data = x, type='line', radius=0)
hp$colors(c("darkblue"))
hp
hp <- hPlot(MLII ~ Seconds, data = x, type='line', radius=0)
hp
hp$color(c("darkblue"))
hp$colors(c("darkblue"))
hp
hp <- hPlot(MLII ~ Seconds, data = x, type='line', radius=0)
hp$series(list(data=list(x$V5 ~ x$Seconds)))
hp
hp <- hPlot(MLII ~ Seconds, data = x, type='line', radius=0)
hp$series(list(data=list(x$V5)))
hp
hp$series(list(data=list(x$V5)))
makeDisplay(byMin,
name = "ecg_by_ten_sec_interval",
desc = "ECG Readings Viewed Per 10 Second Intervals",
panelFn = timePanelhc, cogFn = heartCog,
width = 400, height = 400,
lims = list(x = "same"))
makeDisplay(byMin,
name = "ecg_by_ten_sec_interval",
desc = "ECG Readings Viewed Per 10 Second Intervals",
panelFn = timePanelhc, cogFn = heartCog,
width = 400, height = 400)
library(shiny)
runApp("trelliscopeViewerAlacer", launch.browser=TRUE)
runApp("../../inst/trelliscopeViewerAlacer", launch.browser=TRUE)
timePanelhc(byMin[[1]][[2]])
timePanelhc(byMin[[1]][[2]])
timePanelhc <- function(x){
hp <- hPlot(MLII ~ Seconds, data = x, type='line', radius=0)
hp
}
timePanelhc(byMin[[1]][[2]])
# add display panel and cog function to vdb
makeDisplay(byMin,
name = "ecg_by_ten_sec_interval",
desc = "ECG Readings Viewed Per 10 Second Intervals",
panelFn = timePanelhc, cogFn = heartCog,
width = 400, height = 400)
# view the display
library(shiny)
runApp("../../inst/trelliscopeViewerAlacer", launch.browser=TRUE)
head(r100)
table(r100$AnnotationType)
r100l <- melt(r100[,c("Seconds","TenSecond","MLII","V5","AnnotationType")], id.vars=c("Seconds", "TenSecond"))
library(reshape2)
r100l <- melt(r100[,c("Seconds","TenSecond","MLII","V5","AnnotationType")], id.vars=c("Seconds", "TenSecond"))
head(r100l)
a100$ETime <- strptime(a100$ElapsedTime, format="%M:%OS")
a100$Minutes <- as.numeric(format(a100$ETime, "%M"))
a100$Seconds <- as.numeric(format(a100$ETime, "%OS"))+(a100$Minutes*60)
a100$TenSecond <- floor(a100$Seconds/10)
a100l <- melt(a100[,c("Seconds","TenSecond","Type")], id.vars=c("Seconds", "TenSecond"))
head(a100l)
r100l <- melt(r100[,c("Seconds","TenSecond","MLII","V5")], id.vars=c("Seconds", "TenSecond"))
head(r100l)
a100l <- melt(a100[,c("Seconds","TenSecond","Type")], id.vars=c("Seconds", "TenSecond"))
alldata <- rbind(r100l, a100l)
alldata$Annotation[alldata$variable=="Type"] <- alldata$value[alldata$variable=="Type"]
tail(alldata)
alldata$value[alldata$variable=="Type"] <- -1
byMin <- divide(alldata, by = c("TenSecond"), update = TRUE)
vdbConn("MITDBGraphs/vdb", autoYes = TRUE)
heartCog <- function(x) { list(
meanMLII = cogMean(x$MLII),
RangeMLII = cogRange(x$MLII),
nObs = cog(sum(!is.na(x$MLII)),
desc = "number of sensor readings"),
meanV5 = cogMean(x$V5),
RangeV5 = cogRange(x$V5)
)}
heartCog(byMin[[1]][[2]])
heartCog <- function(x) { list(
meanMLII = cogMean(x$value[x$variable=="MLII"]),
RangeMLII = cogRange(x$value[x$variable=="MLII"]),
nObs = cog(sum(!is.na(x$value[x$variable=="MLII"])),
desc = "number of sensor readings"),
meanV5 = cogMean(x$value[x$variable=="V5"]),
RangeV5 = cogRange(x$value[x$variable=="MLII"])
)}
heartCog(byMin[[1]][[2]])
head(byMin[[1]][[2]])
str(byMin[[1]][[2]])
str(r100l)
byMin <- divide(r100l, by = c("TenSecond"), update = TRUE)
vdbConn("MITDBGraphs/vdb", autoYes = TRUE)
heartCog <- function(x) {list(
meanMLII = cogMean(x$value[x$variable=="MLII"]),
RangeMLII = cogRange(x$value[x$variable=="MLII"]),
nObs = cog(sum(!is.na(x$value[x$variable=="MLII"])),
desc = "number of sensor readings"),
meanV5 = cogMean(x$value[x$variable=="V5"]),
RangeV5 = cogRange(x$value[x$variable=="MLII"])
)}
heartCog(byMin[[1]][[2]])
timePanel <- function(x)
xyplot(value ~ Seconds, group=variable
data = x, auto.key = TRUE, type="l")
timePanel(byMin[[1]][[2]])
timePanel <- function(x)
xyplot(value ~ Seconds, group=variable,
data = x, auto.key = TRUE, type="l")
timePanel(byMin[[1]][[2]])
library(rCharts)
x <- byMin[[1]][[2]]
hp <- hPlot(value ~ Seconds, group=variable, data = x, type='line', radius=0)
hp <- hPlot(value ~ Seconds, group=x$variable, data = x, type='line', radius=0)
hp <- hPlot(value ~ Seconds, group='variable', data = x, type='line', radius=0)
hp
library(rCharts)
x <- byMin[[1]][[2]]
timePanelhc <- function(x){
hp <- hPlot(value ~ Seconds, group='variable', data = x, type='line', radius=0)
hp
}
timePanelhc(byMin[[1]][[2]])
r100$TenSecond <- floor(r100$Seconds/10)
r100$TenSecond <- factor(r100$TenSecond, levels=sort(r100$TenSecond))
r100l <- melt(r100[,c("Seconds","TenSecond","MLII","V5")], id.vars=c("Seconds", "TenSecond"))
r100$TenSecond <- factor(r100$TenSecond, levels=sort(unique(r100$TenSecond))
r100$TenSecond <- factor(r100$TenSecond, levels=sort(unique(r100$TenSecond)))
r100$TenSecond <- factor(r100$TenSecond, levels=sort(unique(r100$TenSecond)))
sort(unique(r100$TenSecond)
)
a100$TenSecond <- floor(a100$Seconds/10)
r100$TenSecond <- factor(r100$TenSecond, levels=sort(unique(r100$TenSecond)))
r100l <- melt(r100[,c("Seconds","TenSecond","MLII","V5")], id.vars=c("Seconds", "TenSecond"))
head(r100l)
byMin <- divide(r100l, by = c("TenSecond"), update = TRUE)
vdbConn("MITDBGraphs/vdb", autoYes = TRUE)
heartCog <- function(x) {list(
meanMLII = cogMean(x$value[x$variable=="MLII"]),
RangeMLII = cogRange(x$value[x$variable=="MLII"]),
nObs = cog(sum(!is.na(x$value[x$variable=="MLII"])),
desc = "number of sensor readings"),
meanV5 = cogMean(x$value[x$variable=="V5"]),
RangeV5 = cogRange(x$value[x$variable=="MLII"])
)}
heartCog(byMin[[1]][[2]])
# make and test panel function
timePanel <- function(x)
xyplot(value ~ Seconds, group=variable,
data = x, auto.key = TRUE, type="l")
timePanel(byMin[[1]][[2]])
############################################
#############################################
############################################
#still working on these code pieces!
library(rCharts)
x <- byMin[[1]][[2]]
timePanelhc <- function(x){
hp <- hPlot(value ~ Seconds, group='variable', data = x, type='line', radius=0)
hp
}
timePanelhc(byMin[[1]][[2]])
# add display panel and cog function to vdb
makeDisplay(byMin,
name = "ecg_by_ten_sec_interval",
desc = "ECG Readings Viewed Per 10 Second Intervals",
panelFn = timePanelhc, cogFn = heartCog,
width = 400, height = 400)
# view the display
library(shiny)
runApp("../../inst/trelliscopeViewerAlacer", launch.browser=TRUE)
